---
title: Deployment
description: 'Deploy Nexo apps to any platform with a single binary.'
---

Nexo apps compile to a single binary, making deployment straightforward across any platform.

## Nexo Cloud

The easiest way to deploy Nexo apps is with **Nexo Cloud** - our managed platform at [cloud.nexo.build](https://cloud.nexo.build).

### Quick Start

```bash
# Login to Nexo Cloud
nexo login

# Deploy your app
nexo deploy
```

That's it! Nexo Cloud handles building, containerization, and deployment automatically.

### Authentication

```bash
# Browser OAuth (default)
nexo login

# Use API token directly
nexo login --token fgc_xxxxxxxxxxxx

# Device flow for headless environments
nexo login --device

# Log out
nexo logout
```

### Application Management

```bash
# List all your apps
nexo apps

# Create a new app
nexo apps create my-api
nexo apps create my-api --region gdl --size starter

# Delete an app
nexo apps delete my-api
nexo apps delete my-api --force  # Skip confirmation
```

### Deployment

```bash
# Build and deploy (default)
nexo deploy

# Deploy without rebuilding
nexo deploy --no-build

# Set environment variables during deploy
nexo deploy --env DATABASE_URL=postgres://...

# Deploy to specific app
nexo deploy --app my-api

# Rollback to previous deployment
nexo rollback my-api

# Rollback to specific deployment
nexo rollback my-api abc123
```

The deploy command:
1. Reads `nexo.yaml` for app configuration
2. Builds the Go binary
3. Creates a Docker image
4. Pushes to container registry
5. Triggers deployment on Nexo Cloud
6. Streams deployment logs

### Logs & Monitoring

```bash
# View recent logs
nexo logs my-api

# Stream logs in real-time
nexo logs my-api -f

# Last 100 lines
nexo logs my-api --tail 100

# Logs from the last hour
nexo logs my-api --since 1h

# Filter by level
nexo logs my-api --level error

# View app status, deployments, and metrics
nexo status my-api
```

### Environment Variables

```bash
# List variables (values redacted)
nexo env my-api

# Show actual values
nexo env my-api --show

# Set variables
nexo env my-api set DATABASE_URL=postgres://...
nexo env my-api set API_KEY=secret DEBUG=true

# Remove variables
nexo env my-api unset DEBUG
```

### Custom Domains

```bash
# List domains
nexo domains my-api

# Add a domain
nexo domains my-api add api.example.com

# Verify DNS configuration
nexo domains my-api verify api.example.com

# Remove a domain
nexo domains my-api remove api.example.com
```

After adding a domain, configure DNS:
```
Type:  CNAME
Name:  api.example.com
Value: my-api.nexo.build
```

### Configuration

Add a `cloud` section to your `nexo.yaml`:

```yaml
name: my-api
port: 3000

cloud:
  region: gdl           # Deployment region
  size: starter         # Instance size (starter, pro, enterprise)
  domains:              # Custom domains
    - api.example.com
  env_file: .env.production  # Env file for deploy
```

### JSON Output

All commands support `--json` for automation:

```bash
nexo apps --json
nexo status my-api --json
nexo logs my-api --json
```

---

## Building for Production

```bash
# Using Nexo CLI
nexo build

# Or directly with Go
go build -o myapp .

# With optimizations
go build -ldflags="-s -w" -o myapp .
```

<Info>
The `-ldflags="-s -w"` strips debug information, reducing binary size by ~30%.
</Info>

## Docker

### Simple Dockerfile

```dockerfile
FROM golang:1.23-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -ldflags="-s -w" -o server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /app
COPY --from=builder /app/server .
COPY --from=builder /app/static ./static
EXPOSE 3000
CMD ["./server"]
```

### Multi-stage with Tailwind

If using Tailwind CSS:

```dockerfile
FROM golang:1.23-alpine AS builder
WORKDIR /app

# Install Nexo CLI for Tailwind
RUN go install github.com/abdul-hamid-achik/nexo/cmd/nexo@latest

COPY go.mod go.sum ./
RUN go mod download
COPY . .

# Build Tailwind CSS
RUN nexo tailwind build

# Build Go binary
RUN go build -ldflags="-s -w" -o server .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /app
COPY --from=builder /app/server .
COPY --from=builder /app/static ./static
EXPOSE 3000
CMD ["./server"]
```

### Docker Compose

```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NEXO_PORT=3000
      - NEXO_HOST=0.0.0.0
    restart: unless-stopped
```

## Cloud Platforms

<Tabs>
  <Tab title="Fly.io">
Fly.io is excellent for Go apps with global distribution.

```bash
# Install flyctl
curl -L https://fly.io/install.sh | sh

# Launch (creates fly.toml)
fly launch

# Deploy
fly deploy
```

**fly.toml:**
```toml
app = "myapp"
primary_region = "dfw"

[build]
  builder = "paketobuildpacks/builder:base"

[http_service]
  internal_port = 3000
  force_https = true

[[services]]
  internal_port = 3000
  protocol = "tcp"

  [[services.ports]]
    port = 80
    handlers = ["http"]

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]
```
  </Tab>
  <Tab title="Railway">
Railway auto-detects Go projects.

1. Push your code to GitHub
2. Connect Railway to your repo
3. Railway automatically builds and deploys

**Environment variables:**
```
NEXO_PORT=3000
NEXO_HOST=0.0.0.0
```
  </Tab>
  <Tab title="Render">
1. Create a new Web Service on Render
2. Connect your GitHub repository
3. Configure:
   - **Build Command:** `go build -ldflags="-s -w" -o server .`
   - **Start Command:** `./server`
   - **Environment:** Go
  </Tab>
  <Tab title="Heroku">
**Procfile:**
```
web: ./bin/myapp
```

```bash
heroku create myapp
heroku buildpacks:set heroku/go
git push heroku main
```
  </Tab>
</Tabs>

## AWS

<Tabs>
  <Tab title="Lambda">
Use a Lambda adapter:

```go
package main

import (
    "github.com/aws/aws-lambda-go/lambda"
    "github.com/awslabs/aws-lambda-go-api-proxy/httpadapter"
    "github.com/abdul-hamid-achik/nexo/pkg/nexo"
)

var app *nexo.App

func init() {
    app = nexo.New()
    // Configure routes
}

func main() {
    lambda.Start(httpadapter.New(app).ProxyWithContext)
}
```
  </Tab>
  <Tab title="ECS/Fargate">
Use the Docker image with ECS task definition:

```json
{
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "your-ecr-repo/myapp:latest",
      "portMappings": [
        {
          "containerPort": 3000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {"name": "NEXO_PORT", "value": "3000"}
      ]
    }
  ]
}
```
  </Tab>
  <Tab title="Elastic Beanstalk">
1. Create `Procfile`:
   ```
   web: ./application
   ```

2. Create `Buildfile`:
   ```
   build: go build -o application .
   ```

3. Deploy:
   ```bash
   eb init
   eb create myapp-env
   eb deploy
   ```
  </Tab>
</Tabs>

## Google Cloud Platform

<Tabs>
  <Tab title="Cloud Run">
Cloud Run is ideal for containerized Go apps:

```bash
# Build and push
gcloud builds submit --tag gcr.io/PROJECT_ID/myapp

# Deploy
gcloud run deploy myapp \
  --image gcr.io/PROJECT_ID/myapp \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated
```

Or deploy from source:

```bash
gcloud run deploy --source .
```
  </Tab>
  <Tab title="App Engine">
**app.yaml:**
```yaml
runtime: go122
env: standard

handlers:
  - url: /static
    static_dir: static

  - url: /.*
    script: auto
```

Deploy:
```bash
gcloud app deploy
```
  </Tab>
  <Tab title="GKE">
**deployment.yaml:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: myapp
          image: gcr.io/PROJECT_ID/myapp:latest
          ports:
            - containerPort: 3000
          env:
            - name: NEXO_PORT
              value: "3000"
---
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 3000
  selector:
    app: myapp
```
  </Tab>
</Tabs>

## Configuration

### Environment Variables

Nexo reads configuration from environment variables:

| Variable | Description | Default |
|----------|-------------|---------|
| `NEXO_PORT` | Server port | `3000` |
| `NEXO_HOST` | Server host | `localhost` |
| `NEXO_ENV` | Environment (dev/prod) | `dev` |
| `NEXO_LOG_LEVEL` | Log level | `info` |

### nexo.yaml

```yaml
port: 3000
host: "0.0.0.0"
app_dir: "app"
static_dir: "static"
static_path: "/static"

# Production settings
prod:
  hot_reload: false
```

## Health Checks

Add a health endpoint for load balancers:

```go
// app/api/health/route.go
package health

import "github.com/abdul-hamid-achik/nexo/pkg/nexo"

func Get(c *nexo.Context) error {
    return c.JSON(200, map[string]string{
        "status": "healthy",
    })
}
```

Configure your load balancer to check `/api/health`.

## Static Files

Ensure static files are included in deployment:

```go
app.Static("/static", "static")
```

For Docker, copy the static directory:
```dockerfile
COPY --from=builder /app/static ./static
```

## Graceful Shutdown

Nexo handles SIGINT and SIGTERM for graceful shutdown automatically. In Kubernetes, configure a termination grace period:

```yaml
spec:
  terminationGracePeriodSeconds: 30
```

## Production Checklist

<AccordionGroup>
  <Accordion title="Security">
    - Enable HTTPS
    - Set secure headers (`app.Use(nexo.SecureHeaders())`)
    - Use environment variables for secrets
    - Enable CORS properly
  </Accordion>
  <Accordion title="Performance">
    - Build with `-ldflags="-s -w"`
    - Enable response compression
    - Set appropriate cache headers
    - Use connection pooling for databases
  </Accordion>
  <Accordion title="Monitoring">
    - Add health check endpoint
    - Configure logging level for production
    - Set up metrics collection
    - Configure alerting
  </Accordion>
  <Accordion title="Reliability">
    - Use graceful shutdown
    - Configure request timeouts
    - Add rate limiting
    - Set up load balancing
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Quick Start" icon="rocket" href="/docs/getting-started/quickstart">
    Build your first app
  </Card>
  <Card title="Configuration" icon="gear" href="/docs/advanced/configuration">
    Full configuration reference
  </Card>
  <Card title="Performance" icon="gauge-high" href="/docs/advanced/performance">
    Optimization tips
  </Card>
  <Card title="Examples" icon="code" href="/docs/guides/examples">
    Working code samples
  </Card>
</CardGroup>
